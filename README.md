```
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–‘â–ˆâ–ˆâ•—â–‘â–‘â–‘â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ•—â–‘â–‘â–‘â–ˆâ–ˆâ•—
â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–‘â–‘â–‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–‘â–‘â–‘â–‘â–‘â•šâ–ˆâ–ˆâ•—â–‘â–ˆâ–ˆâ•”â•
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–‘â–‘â–‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–‘â–‘â–‘â–‘â–‘â–‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–‘
â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–‘â–‘â–‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â•šâ–ˆâ–ˆâ•”â•â–‘â–‘
â–ˆâ–ˆâ•‘â–‘â–‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–‘â–‘â–‘â–ˆâ–ˆâ•‘â–‘â–‘â–‘
â•šâ•â•â–‘â–‘â•šâ•â•â–‘â•šâ•â•â•â•â•â•â–‘â•šâ•â•â•â•â•â•â•â–‘â–‘â–‘â•šâ•â•â–‘â–‘â–‘
```

## ğŸš€ Quick Install

### One-Line Installation

```bash
curl -fsSL https://raw.githubusercontent.com/patrickclery/ruly/main/setup.rb -o /tmp/ruly_setup.rb && ruby /tmp/ruly_setup.rb
```

This will:

- Install Ruly to `~/ruly`
- Add `ruly` command to your PATH
- Set up initial configuration at `~/.config/ruly/recipes.yml`

### Manual Installation

If you prefer to install manually:

```bash
# Clone the repository
git clone https://github.com/patrickclery/ruly.git ~/ruly
cd ~/ruly

# Install dependencies
bundle config set --local path 'vendor/bundle'
bundle install

# Add to PATH (add to your ~/.bashrc or ~/.zshrc)
export PATH="$HOME/ruly/bin:$PATH"

# Initialize configuration
ruly init
```

### Uninstall

To remove Ruly:

```bash
rm -rf ~/ruly
# Remove the PATH export from your shell configuration file
```

### Getting Started

After installation, you can immediately start using Ruly:

```bash
# Initialize configuration (if not done during install)
$ ruly init

# List available commands
$ ruly help

# Combine all rules into one file
$ ruly squash

# Use a specific recipe
$ ruly squash starter

# Clean up generated files
$ ruly clean

# List available recipes
$ ruly list-recipes

# Show version
$ ruly version
```

## ğŸŒŸ How It Works

### Standalone CLI Tool

Ruly is a standalone command-line tool that manages AI assistant rules:

1. **Simple Installation**: One-line install with curl
2. **Self-Contained**: Everything runs from `~/ruly`
3. **Recipe System**: Use pre-configured recipes or create your own
4. **Smart Caching**: Cache compiled recipes for performance
5. **Multiple Formats**: Support for different AI assistants (Claude, Cursor, etc.)

**Benefits:**

- âœ… **Standalone**: No gem installation required
- âœ… **Easy updates**: Just pull the latest changes
- âœ… **No system dependencies**: Self-contained in your home directory
- âœ… **Flexible rules system**: Define your own rules repository or use remote sources
- âœ… **Cross-platform**: Works anywhere Ruby is installed

### What Ruly Does

**The `ruly` command provides:**

- âœ… Combine multiple rule files into one document
- âœ… Use recipe collections for different contexts
- âœ… Fetch and include remote GitHub files
- âœ… Cache compiled recipes for performance
- âœ… Support for Claude, Cursor, and other AI assistants
- âœ… Clean up all agent-related files automatically

**Generated Files:**

```
your-project/
â”œâ”€â”€ CLAUDE.local.md      # Generated by ruly squash (default)
â””â”€â”€ .claude/
    â””â”€â”€ commands/        # Command files for Claude agent
        â”œâ”€â”€ bug/         # Bug-related commands
        â”œâ”€â”€ pr/          # PR management commands
        â”œâ”€â”€ testing/     # Testing commands
        â””â”€â”€ workflow/    # Workflow commands
```

For other agents:

- **Cursor**: Uses `.cursor/` directory with `.mdc` files
- **Custom**: Specify with `--agent` and `--output-file` options

---

## About Ruly

Ruly is a powerful CLI tool that manages AI assistant rules and configurations for software development projects. It provides a framework for organizing and combining rule files from various sources - your own private repositories, public GitHub repos, or local files - into a single document for AI assistants like Claude or Cursor.

### âš ï¸ Important: Rules Not Included

This repository **does not include rule files**. You need to:

1. Create your own rules repository (private or public)
2. Configure recipes to point to your rule sources
3. Use the `ruly init` command to get started with a template

## ğŸ¯ Setting Up Your Rules

### Option 1: Create Your Own Rules Repository

1. **Create a new repository for your rules:**

   ```bash
   # Create a private repository
   gh repo create yourusername/rules --private --description "My AI assistant rules"

   # Clone it locally
   git clone git@github.com:yourusername/rules.git
   cd rules
   ```

2. **Organize your rules:**

   ```
   rules/
   â”œâ”€â”€ ruby/
   â”‚   â”œâ”€â”€ common.md
   â”‚   â”œâ”€â”€ rspec.md
   â”‚   â””â”€â”€ best-practices.md
   â”œâ”€â”€ testing/
   â”‚   â””â”€â”€ patterns.md
   â”œâ”€â”€ commands/
   â”‚   â”œâ”€â”€ bug/
   â”‚   â”‚   â””â”€â”€ diagnose.md
   â”‚   â””â”€â”€ pr/
   â”‚       â””â”€â”€ create.md
   â”œâ”€â”€ comms/
   â”‚   â”œâ”€â”€ jira/
   â”‚   â”‚   â”œâ”€â”€ common.md           # Shared Jira patterns
   â”‚   â”‚   â””â”€â”€ bin/                # Shell scripts for Jira operations
   â”‚   â”‚       â””â”€â”€ fetch-jira-details.sh
   â”‚   â””â”€â”€ ms-teams/
   â”‚       â”œâ”€â”€ common.md           # Shared Teams patterns
   â”‚       â”œâ”€â”€ commands/
   â”‚       â”‚   â””â”€â”€ dm.md           # User-facing command
   â”‚       â””â”€â”€ agents/
   â”‚           â””â”€â”€ ms-teams-dm.md  # Subagent instructions
   â”œâ”€â”€ github/
   â”‚   â”œâ”€â”€ pr/
   â”‚   â”‚   â””â”€â”€ bin/                # Shell scripts for PR operations
   â”‚   â”‚       â””â”€â”€ fetch-pr-details.sh
   â”‚   â””â”€â”€ bin/                    # General GitHub scripts
   â”‚       â””â”€â”€ git_prettycommit.rb
   â””â”€â”€ core/
       â””â”€â”€ debugging.md
   ```

   **Directory conventions:**
   - `commands/` - User-invocable slash commands (e.g., `/ms-teams:dm`)
   - `agents/` - Subagent instruction files (dispatched by orchestrator, not user-invocable)
   - `bin/` - Shell scripts and executables used by rules (add to PATH for CLI access)
   - Root files - Common patterns and shared configuration

### Option 2: Use Multiple Rule Sources

Create `~/.config/ruly/recipes.yml` to combine rules from different repositories:

```yaml
recipes:
  my-complete-rules:
    description: "Combines personal and company rules"
    sources:
      # Your personal rules repository
      - github: yourusername/rules
        branch: main
        rules:
          - ruby
          - testing
          - commands

      # Company rules (e.g., "FakeCorp")
      - github: fakecorp/development-standards
        branch: main
        rules:
          - guidelines/code-review.md
          - guidelines/security.md

      # Individual files from public repos
      - https://github.com/thoughtbot/guides/blob/main/ruby/README.md
```

### Option 3: Quick Start with Init

After installing Ruly, you can quickly get started with a basic configuration:

```bash
# Initialize Ruly with a starter configuration
ruly init

# This creates ~/.config/ruly/recipes.yml with example recipes
# Edit this file to add your own rule sources
```

### Option 4: Use Remote Sources Only

If you don't want to maintain your own rules repository, you can use rules directly from GitHub:

```yaml
recipes:
  remote-only:
    description: "Rules from various GitHub sources"
    sources:
      # Individual files
      - https://github.com/rubocop/ruby-style-guide/blob/master/README.md
      - https://github.com/testdouble/standard/blob/main/docs/README.md

      # Entire directories (expands to all .md files)
      - https://github.com/fakecorp/standards/tree/main/ruby
      - https://github.com/fakecorp/standards/tree/main/testing
```

### Example: Setting Up Like patrickclery/rules

Here's how the maintainer set up their private rules repository:

1. **Created a private repository:**

   ```bash
   gh repo create patrickclery/rules --private --description "Private rules for Ruly gem"
   ```

2. **Created your rules content and pushed to GitHub**

3. **Updated your Ruly configuration:**

   ```yaml
   # ~/.config/ruly/recipes.yml
   recipes:
     complete:
       description: "Personal + FakeCorp rules"
       sources:
         - github: patrickclery/rules
           branch: main
           rules:
             - ruby
             - testing
             - commands

         - github: fakecorp/cursor-rules
           branch: main
           rules:
             - workflow
             - jira
   ```

## ğŸ“ Using Ruly Commands

Ruly provides a powerful CLI for managing and compiling your AI assistant rules.

### Basic Commands

**Combine all rules into one file:**

```bash
ruly squash
```

**Use a specific recipe:**

```bash
# Recipe name as positional parameter
ruly squash rails
ruly squash api
```

**Custom output file:**

```bash
# Squash mode with custom output
ruly squash --output-file=combined-rules.md
# or using short option
ruly squash -o docs/my-rules.md

# Combine with recipe
ruly squash rails -o RAILS.md
```

**Analyze token usage:**

```bash
# Analyze a specific recipe
ruly analyze rails
ruly analyze api

# Analyze all recipes
ruly analyze --all
ruly analyze -a
```

**Clean up generated files:**

```bash
# Clean all agent-related files for current agent
ruly clean

# Clean files from specific recipe
ruly clean rails

# Clean files for specific agent
ruly clean --agent cursor

# Dry run to see what would be deleted
ruly clean --dry-run
ruly clean -d

# Clean before squashing (remove old files first)
ruly squash --clean
ruly squash rails --clean
ruly squash -c  # Short form

# Deep clean before squashing (remove ALL Claude artifacts)
ruly squash --deepclean
ruly squash rails --deepclean
```

**Generate MCP server configuration:**

```bash
# Create .mcp.json with specific servers (must exist in ~/.config/ruly/mcp.json)
ruly mcp atlassian teams playwright

# Use MCP servers from a recipe
ruly mcp -r workaxle-spike
ruly mcp --recipe workaxle-bug

# Append to existing .mcp.json instead of overwriting
ruly mcp playwright -a
ruly mcp --append task-master-ai

# Combine recipe servers with additional servers
ruly mcp -r workaxle-bug playwright

# Append recipe servers to existing config
ruly mcp -r workaxle-spike -a
```

### Subagents

Subagents allow you to generate specialized agent files that Claude can dispatch to for specific tasks. Each subagent is a self-contained agent with its own rules, commands, and MCP server access.

#### Defining Subagents in Recipes

Add a `subagents` array to any recipe. Each subagent references another recipe:

```yaml
recipes:
  # Main recipe that spawns subagents
  full:
    description: "Complete development environment"
    files:
      - /path/to/rules/core.md
    subagents:
      - name: bug_investigator
        recipe: bug
      - name: test_runner
        recipe: testing
      - name: pr_manager
        recipe: pr

  # Recipes used by subagents
  bug:
    description: "Bug investigation and debugging"
    files:
      - /path/to/rules/bug/
      - /path/to/rules/debugging.md
    mcp_servers:
      - task-master-ai

  testing:
    description: "Testing and QA workflows"
    files:
      - /path/to/rules/testing/
    mcp_servers:
      - playwright

  pr:
    description: "PR management"
    files:
      - /path/to/rules/github/pr/
```

#### How It Works

When you run `ruly squash -r full`:

1. **MCP servers collected**: Recursively collects `mcp_servers` from all subagent recipes
2. **`.mcp.json` written**: Parent's `.mcp.json` includes all collected servers (deduplicated)
3. **Main rules generated**: `CLAUDE.local.md` with the main recipe content
4. **Agent files created**: `.claude/agents/{name}.md` for each subagent
5. **Commands organized**: `.claude/commands/{agent_name}/` for agent-specific commands

```
your-project/
â”œâ”€â”€ CLAUDE.local.md              # Main rules (from 'full' recipe)
â”œâ”€â”€ .mcp.json                    # MCP servers (parent + all subagent servers)
â””â”€â”€ .claude/
    â”œâ”€â”€ agents/
    â”‚   â”œâ”€â”€ bug_investigator.md  # Squashed 'bug' recipe
    â”‚   â”œâ”€â”€ test_runner.md       # Squashed 'testing' recipe
    â”‚   â””â”€â”€ pr_manager.md        # Squashed 'pr' recipe
    â””â”€â”€ commands/
        â”œâ”€â”€ bug_investigator/    # Commands for bug agent
        â”œâ”€â”€ test_runner/         # Commands for testing agent
        â””â”€â”€ pr_manager/          # Commands for PR agent
```

#### MCP Server Propagation

Claude Code subagents inherit the parent session's MCP configuration â€” they cannot have independent MCP servers. Ruly handles this automatically: during `ruly squash`, MCP servers from all subagent recipes (recursively, including nested subagents) are collected and merged into the parent's `.mcp.json`.

For example, given this recipe configuration:

```yaml
recipes:
  core:
    description: "Main orchestrator"
    files:
      - /path/to/rules/core.md
    # Note: no mcp_servers defined here
    subagents:
      - name: comms
        recipe: comms
      - name: feature
        recipe: feature

  comms:
    description: "Communication agent"
    files:
      - /path/to/rules/comms/
    mcp_servers:
      - teams
      - mattermost

  feature:
    description: "Feature development"
    files:
      - /path/to/rules/feature/
    mcp_servers:
      - Ref
```

Running `ruly squash core` produces a `.mcp.json` containing `teams`, `mattermost`, and `Ref` â€” all propagated from the subagent recipes â€” even though `core` itself defines no MCP servers. The console output shows which servers were propagated:

```
ğŸ”Œ Propagated MCP servers from subagents: teams, mattermost, Ref
ğŸ”Œ Updated .mcp.json with MCP servers
```

This propagation is recursive: if `comms` itself has subagents with additional MCP servers, those are collected too. Circular references are handled safely.

#### Agent File Format

Generated agent files have YAML frontmatter that Claude understands:

```yaml
---
name: bug_investigator
description: Bug investigation and debugging
tools: inherit
model: inherit
# Auto-generated from recipe: bug
# Do not edit manually - regenerate using 'ruly squash full'
---

# Bug Investigator

Bug investigation and debugging

## Recipe Content

[squashed content from bug recipe]

## MCP Servers

This subagent has access to the following MCP servers:
- task-master-ai

---
*Last generated: 2026-02-04 12:30:00*
*Source recipe: bug*
```

#### Directory Structure for Subagents

Subagent instruction files should be organized in `agents/` directories:

```
rules/
â””â”€â”€ comms/
    â”œâ”€â”€ ms-teams/
    â”‚   â”œâ”€â”€ common.md                     # Shared patterns (loaded by both)
    â”‚   â”œâ”€â”€ commands/
    â”‚   â”‚   â””â”€â”€ dm.md                     # User command: /ms-teams:dm
    â”‚   â””â”€â”€ agents/
    â”‚       â””â”€â”€ ms-teams-dm.md            # Subagent: dispatched on "send it"
    â””â”€â”€ mattermost/
        â”œâ”€â”€ common.md                     # Shared patterns (loaded by both)
        â”œâ”€â”€ commands/
        â”‚   â””â”€â”€ dm.md                     # User command: /mattermost:dm
        â””â”€â”€ agents/
            â””â”€â”€ mattermost-dm.md          # Subagent: dispatched on "send it"
```

**Key distinction:**
- `commands/` - User-invocable via `/command-name`
- `agents/` - Dispatched programmatically by the orchestrator

#### When to Use Subagents

| Use Case | Benefit |
|----------|---------|
| **Specialized tasks** | Each agent has focused rules for its domain |
| **Parallel work** | Dispatch multiple agents for independent tasks |
| **Context isolation** | Agents only load rules they need |
| **MCP server propagation** | Subagent MCP servers are automatically propagated to parent |

#### Example: Development Workflow

```yaml
recipes:
  workaxle:
    description: "Main WorkAxle development"
    files:
      - /path/to/rules/core.md
    subagents:
      - name: comms
        recipe: comms        # Jira, Teams, GitHub communications
      - name: merger
        recipe: merger       # PR merging operations
      - name: dashboard
        recipe: dashboard    # PR status dashboard

  comms:
    description: "Communication via Jira, Teams, GitHub"
    files:
      - /path/to/rules/comms/
    mcp_servers:
      - teams
      - atlassian

  merger:
    description: "PR merging commands"
    files:
      - /path/to/rules/github/pr/
    mcp_servers: []

  dashboard:
    description: "Open PRs dashboard"
    files:
      - /path/to/rules/dashboard.md
    mcp_servers: []
```

Then Claude can dispatch to these agents:

```
User: "Update all my PRs with latest main"
Claude: [Dispatches to merger agent which has PR merge rules]

User: "Send a Teams message about WA-1234"
Claude: [Dispatches to comms agent which has Teams MCP access]

User: "Show me my open PRs"
Claude: [Dispatches to dashboard agent]
```

### Recipe System

Recipes allow you to define collections of rules to combine, rather than always including all files.

**List available recipes:**

```bash
ruly list-recipes
```

**Use a specific recipe:**

```bash
# Use the 'core' recipe
ruly squash --recipe core

# Use 'testing' recipe with custom output
ruly squash --recipe testing -o testing-rules.md

# Short form
ruly squash -r minimal
```

#### Available Recipes

Recipes depend on having access to rule files. If you cloned with the default rules submodule, you'll have access to the recipes defined in `recipes.yml`. Otherwise, create your own recipes in `~/.config/ruly/recipes.yml` pointing to your rule sources.

#### Custom Recipes

Create a `~/.config/ruly/recipes.yml` file to define your own recipes or override existing ones:

```yaml
# ~/.config/ruly/recipes.yml
---
plan: claude_max
recipes:
  # Complete development environment combining multiple sources
  my_company_core:
    description: Complete development environment with Ruby, testing, and workflow rules
    plan: claude_max
    sources:
      # John's private rules repository
      - github: john/private-rules
        branch: main
        rules:
          - rules/commands/bug
          - rules/commands/pr
          - rules/bug
          - rules/commands.md
          - rules/core
          - rules/core/debugging
          - rules/pr
          - rules/ruby
          - rules/testing
          - rules/commands/testing
          - rules/commands/workflow

      # Company's shared rules repository
      - github: my_company/development-standards
        branch: main
        rules:
          - rules/commands/jira/details.md
          - rules/workflow
          - rules/jira

  # Local files from various projects
  development_local:
    description: Auto-generated from local sources
    files:
      - /Users/john/Projects/my_app/rules/ruby/common.md
      - /Users/john/Projects/my_app/rules/ruby/monads.md
      - /Users/john/Projects/my_app/rules/ruby/rspec.md
      - /Users/john/Projects/my_app/rules/ruby/sequel.md
      - /Users/john/Projects/my_app/rules/testing/common.md
      - /Users/john/Projects/my_app/rules/commands.md
      - /Users/john/Projects/my_app/rules/commands/bug/diagnose.md
      - /Users/john/Projects/my_app/rules/commands/bug/fix.md
      - /Users/john/Projects/my_app/rules/commands/pr/create.md
    plan: claude_max

  # Simple recipe for specific context
  testing_only:
    description: Testing and QA rules
    plan: claude_max
    files:
      - /Users/john/Projects/my_app/rules/testing/*.md
      - /Users/john/Projects/my_app/rules/commands/testing/*.md
```

**Remote Sources:**

- Supports pulling rules directly from GitHub repositories
- Automatically converts GitHub blob URLs to raw URLs
- Command files (files with "command" in path/name) are saved to `.claude/commands/` when using
  `--agent claude`
- Non-Claude agents include all files in the main output

**GitHub URL Formats:**

- **Individual files**: Use `/blob/` URLs for specific files
  - Example: `https://github.com/owner/repo/blob/branch/path/to/file.md`
- **Directories**: Use `/tree/` URLs to include all `.md` files in a directory
  - Example: `https://github.com/owner/repo/tree/branch/path/to/directory`
  - Automatically expands to include all markdown files in that directory
- **Important**: Files with extensions (like `.md`) in `/tree/` URLs are treated as individual files, not directories

**Command File Handling:**

- When `--agent claude` (default), command files are saved to `.claude/commands/`
- For other agents, command files are included in the main output file
- Command detection: files in `/commands/` directories or with "command" in the filename

**Caching:**

- Use `--cache` flag to enable caching for any recipe
- Cached files are stored in `cache/<agent>/` directory
- Remote files are cached separately in `cache/remote/` (7-day expiration)
- Cache is disabled by default
- Use `ruly clean` to remove cache files

User recipes:

- Are automatically loaded from `~/.config/ruly/recipes.yml`
- Override base recipes with the same name
- Are stored in your home directory configuration
- Allow user-specific or team-specific customizations

### Commands

- **Squash** (`squash [RECIPE]`): Combines all rule content into a single large file. Recipe is
  optional positional parameter. Supports fetching remote GitHub files and caching for performance.
  Use `--toc` or `-t` to generate a table of contents with unique anchors for all headers, ensuring proper navigation even when multiple files have identical header names. Also includes a list of available slash commands.
  Use `--deepclean` to remove all Claude artifacts before squashing (overrides `--clean`).
  Use `--verbose` or `-v` to show detailed per-file processing output (file paths, token counts, requires discovery). Default output shows only recipe, subagents, errors, and summary.

- **Analyze** (`analyze [RECIPE]`): Analyzes token usage for recipes without generating files. Shows
  detailed file breakdown and total token count. Use `--all` to analyze all recipes at once.

- **Clean** (`clean [RECIPE]`): Deletes output files created by the squash command. Recipe is
  optional. Removes main output file and command files directory.
  Use `--deepclean` to remove all Claude artifacts (.claude/ directory, CLAUDE.local.md, CLAUDE.md) regardless of recipe.

- **Introspect** (`introspect [FILE_PATH]`): Analyzes a markdown file to extract its frontmatter
  metadata and identify any `requires:` dependencies. Shows the YAML frontmatter, lists required
  files, and displays their resolved paths. Useful for understanding file dependencies and debugging
  the requires system. If no file path is provided, it will look for a file in the current directory.

- **List Recipes** (`list-recipes`): Shows all available recipes with file counts and cache
  indicators.

- **Version** (`version`): Shows the current Ruly version.

### Slash Commands

Slash commands are special commands that can be defined in your rule files to provide quick actions for AI assistants. When you include command files in your rules (typically in a `commands/` directory), they become available as slash commands in the generated output.

For example, if you have a file `commands/bug/diagnose.md` in your rules, it would become available as `/bug:diagnose` when using the generated rules with Claude or other AI assistants.

The `--toc` option will automatically generate:

1. A table of contents with links to all headers in the combined document
2. Unique anchors for headers (prefixed with the source file path) to handle duplicate header names across files
3. A list of all available slash commands in your squashed output

This ensures proper navigation even when multiple rule files contain headers with identical names (e.g., multiple files with "# Introduction" sections).

#### Available Ruly Commands

- `/ruly:compress` - Analyze markdown rules to find redundancies and make them more DRY
- `/ruly:decompose` - Decompose a markdown file into a directory using git mv (preserves history)

### Examples

```bash
# Generate CLAUDE.local.md with all rules
ruly squash

# Dry run - see what would be created without creating it
ruly squash --dry-run
ruly squash -d

# Generate core rules only
ruly squash --recipe core
ruly squash -r core

# Generate squashed testing rules to a custom file
ruly squash -r testing -o test/testing-rules.md

# Generate rules for a different agent (e.g., cursor)
ruly squash -r rails --agent cursor -o CURSOR.md
ruly squash -r rails -a cursor -o CURSOR.md

# Generate with remote sources (command files go to .claude/commands/)
ruly squash -r example_mixed

# Use cached version (if recipe has cache: true)
ruly squash rails

# Bypass cache for one run
ruly squash rails --no-cache

# Clean up generated files
ruly clean

# Dry run - see what would be deleted
ruly clean --dry-run
ruly clean -d

# Deep clean - remove all Claude artifacts
ruly clean --deepclean

# Clean specific output file
ruly clean -o test/testing-rules.md

# Introspect a markdown file to see its frontmatter and requires
ruly introspect rules/ruby/ruby-practices.md

# Introspect a file in the current directory
ruly introspect README.md

# List what recipes are available
ruly list-recipes

# Show version
ruly version

# View help
ruly help
ruly help squash
ruly help clean
ruly help introspect
```

Ruly will automatically:

- Load recipes from both `recipes.yml` and `~/.config/ruly/recipes.yml`
- Support glob patterns in recipe definitions
- Create parent directories if using custom output paths
- Display file count and output size
- Show which recipe was used in the output

## ğŸ”§ Troubleshooting

### Common Issues

**Permission denied:**

- Ensure you have write access to your project directory
- Check that Ruby gems can be installed globally

**Recipe not found:**

- Run `ruly list-recipes` to see available recipes
- Check `~/.config/ruly/recipes.yml` for user-defined recipes
- Ensure recipe names match exactly (case-sensitive)

**Files not being cleaned:**

- Use `ruly clean --dry-run` to preview what will be deleted
- Specify agent with `--agent` option if not using Claude
- Ensure you're using the correct recipe name if specified
